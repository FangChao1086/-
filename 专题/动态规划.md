# 专题_动态规划
* [找零钱问题](#找零钱问题)
* [最小路径和](#最小路径和)
* [LIS_求最长递增子序列长度](#LIS_求最长递增子序列长度)
* [LCS_求最长公共子序列长度](#LCS_求最长公共子序列长度)
* [01背包](#01背包)

<span id="找零钱问题"></span>
## 找零钱问题
```
有数组penny，penny中所有的值都为正数且不重复。
每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim(小于等于1000)代表要找的钱数，求换钱有多少种方法。
给定数组penny及它的大小(小于等于50)，同时给定一个整数aim，请返回有多少种方法可以凑成aim。

样例：
输入：[1,2,4],3,3
返回：2
```
**代码**
```cpp
class Exchange {
public:
    int countWays(vector<int> penny, int n, int aim) {
        // write code here
        vector<vector<int>> dp(n,vector<int>(aim+1,0));
        for(int i=0;i<n;++i)
            dp[i][0]=1;
        for(int i=0;i<=aim;++i)
        {
            if(i%penny[0]==0)
                dp[0][i]=1;
        }
        for(int i=1;i<n;++i)
        {
            for(int j=1;j<aim+1;++j)
            {
                if(j-penny[i]>=0)
                    dp[i][j]=dp[i][j-penny[i]]+dp[i-1][j];
                else
                    dp[i][j]=dp[i-1][j];
            }
        }
        return dp[n-1][aim];
    }
};
```

<span id="最小路径和"></span>
## 最小路径和
```
有一个矩阵map，它每个格子有一个权值。
从左上角的格子开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，返回所有的路径中最小的路径和。
给定一个矩阵map及它的行数n和列数m，请返回最小路径和。保证行列数均小于等于100.

样例：
输入：[[1,2,3],[1,1,1]],2,3
返回：4
```
**代码**
```cpp
class MinimumPath {
public:
    int getMin(vector<vector<int> > map, int n, int m) {
        // write code here
        int a[n][m];
        a[0][0]=map[0][0];
        for(int i=1;i<n;i++)
        {
            a[i][0]=a[i-1][0]+map[i][0];
        }
        for(int j=1;j<m;j++)
        {
            a[0][j]=a[0][j-1]+map[0][j];
        }
        for(int i=1;i<n;i++)
        {
            for(int j=1;j<m;j++)
                a[i][j]=min(a[i-1][j],a[i][j-1])+map[i][j];
        }
        return a[n-1][m-1];
    }
};
```

<span id="LIS_求最长递增子序列长度"></span>
## LIS_求最长递增子序列长度
```
这是一个经典的LIS(即最长上升子序列)问题，请设计一个尽量优的解法求出序列的最长上升子序列的长度。
给定一个序列A及它的长度n(长度小于等于500)，请返回LIS的长度。

样例：
输入：[1,4,2,5,3],5
返回：3
```
**代码**
```cpp
class LongestIncreasingSubsequence {
public:
    int getLIS(vector<int> A, int n) {
        // write code here
        int dp[n];
        dp[0]=1;
        for(int i=1;i<n;i++)
        {
            int max=-1;
            for(int j=0;j<i;j++)
            {
                if(A[j]<A[i] && max<dp[j])
                {
                    max=dp[j];
                    dp[i]=dp[j]+1;
                }
            }
            if(max==-1){
                dp[i]=1;
            }
        }
        int max=dp[0];
        for(int i=0;i<n;i++)
            max=max>dp[i]?max:dp[i];
        return max;
    }
};
```

<span id="LCS_求最长公共子序列长度"></span>
## LCS_求最长公共子序列长度
```
给定两个字符串A和B，返回两个字符串的最长公共子序列的长度。
例如，A="1A2C3D4B56”，B="B1D23CA45B6A”，”123456"或者"12C4B6"都是最长公共子序列。
给定两个字符串A和B，同时给定两个串的长度n和m，请返回最长公共子序列的长度。保证两串长度均小于等于300。

样例：
输入："1A2C3D4B56",10,"B1D23CA45B6A",12
返回：6
```
**代码**
```cpp
class LCS {
public:
    int findLCS(string A, int n, string B, int m) {
        // write code here
        int dp[n+1][m+1];
        memset(dp,0,sizeof(dp));
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
            {
                if (A[i]==B[j])
                    dp[i+1][j+1]=dp[i][j]+1;
                else
                    dp[i+1][j+1]=max(dp[i+1][j],dp[i][j+1]);
            }
        }
        return dp[n][m];
    }
};
```

<span id+"01背包"></span>
## 01背包
```
一个背包有一定的承重cap，有N件物品，每件都有自己的价值，记录在数组v中，也都有自己的重量，记录在数组w中，每件物品只能选择要装入背包还是不装入背包，要求在不超过背包承重的前提下，选出物品的总价值最大。
给定物品的重量w价值v及物品数n和承重cap。请返回最大总价值。

样例：
输入：[1,2,3],[1,2,3],3,6
返回：6
```
**代码**
```cpp
class Backpack {
public:
    int maxValue(vector<int> w, vector<int> v, int n, int cap) {
        // write code here
        int dp[n+1][cap+1];
        memset(dp,0,sizeof(dp));
        for(int i = 1;i <= n; i++){
            for(int j = 1; j <= cap; j++){
                if(j >= w[i-1])
                    dp[i][j] = max(dp[i-1][j], dp[i-1][j - w[i - 1]] + v[i-1]);
                else
                    dp[i][j] = dp[i-1][j];
            }
        }
        return dp[n][cap];
    }
};
```
