# 专题_二叉树
* [二叉树的遍历](#二叉树的遍历)

<span id="二叉树的遍历"></span>
## 二叉树的遍历
```cpp
class TreetoSequence{
public:
    vector<vector<int>> convert(TreeNode* root){
        vector<vector<int>> res;
        vector<int> temp;
        first(root, temp);
        res.push_back(temp);
        temp.clear();
        mid(root, temp);
        res.push_back(temp);
        temp.clear();
        last(root, temp);
        res.push_back(temp);
        temp.clear();
        return res;
   }

    //递归
    //先序遍历
    void first(TreeNode* root, vector<int> &temp){
        if(root == NULL)
            return ;
        temp.push_back(root -> val);
        first(temp -> left, temp);
        first(temp -> right, temp);
    }
    //中序遍历
    void mid(TreeNode* root, vector<int> &temp){
        if(root == NULL)
            return ;
        mid(root -> left, root);
        temp.push_back(root -> val);
        mid(root -> right, temp);
    }
    //后续遍历
    void last(TreeNode* root, vector<int> &temp){
        if(root == NULL)
            return ;
        last(root -> left, temp);
        last(root -> right, temp);
        temp.push_back(root -> val);
    }

   /*
   //非递归
   //先序
   void first(TreeNode* root, vector<int> &temp){
       stack<TreeNode*> s;
       TreeNode* cur = NULL;
       s.push(root);
       while(!s.empty()){
           cur = s.top();
           s.pop();
           temp.push_back(cur -> val);
           if(cur -> right != NULL)
               s.push(cur -> right);
           if(cur -> left != NULL)
               s.push(cur -> left);
       }
   }
   //中序
   void mid(TreeNode* root, vector<int> &temp){
       stack<TreeNode*> s;
       TreeNode* cur = root;
       while(!s.empty() || cur != NULL){
           if(cur != NULL){
               s.push(cur);
               cur = cur -> left;
           }
           else{
               cur = s.top();
               temp.push_back(cur -> val);
               cur = cur -> right;
               s.pop();
           }
       }
   }
   //后序
   void last(TreeNode* root, vector<int> &temp){
       stack<TreeNode*> s1, s2;
       s1.push(root);
       TreeNode* cur = NULL；
       while(!s1.empty()){
           cur = s1.top();
           s2.push(cur);
           s1.pop();
           if(cur -> left != NULL)
               s1.push(cur -> left);
           if(cur -> right != NULL)
               s1.push(cur -> right);
       }
       while(!s2.empty()){
           temp.push_back(s2.top() -> val);
           s2.pop();
       }
   }
   */
};
```
