<span id="re_"></span>
## 专题_数组
[N_sum](#N_sum)
[二分查找](#二分查找)

<span id="N_sum"></span>
## [N_sum](#re_)  [链接](https://blog.csdn.net/wenjianmuran/article/details/90633408)
```cpp
// 要求数组有序

//2_sum
vector<vector<int>> twoSum(vector<int>& nums, int target, int st, int ed) {
    vector<vector<int> > res;
    while (st < ed) {
        if (nums[st] + nums[ed] == target) {
            if (res.empty() || res.back()[0] != nums[st]) {
                res.push_back(vector<int>{nums[st], nums[ed]});
            }
            ++st;
            --ed;
        } else if (nums[st] + nums[ed] > target) {
            --ed;
        } else {
            ++st;
        }
    }
    return res;
}

//n_sum
vector<vector<int>> nSum(vector<int>& nums, int target, int st, int ed, int n) {
    vector<vector<int> > res;
    if (n == 2) {
        return twoSum(nums, target, st, ed);
    } else {
        for (int i=st; i<=ed; ++i) {
            int num = nums[i];
            if (res.empty() || res.back()[0] != num) {
                auto ret = nSum(nums, target-num, i+1, nums.size()-1, n-1);
                for (auto r : ret) {
                    vector<int> tmp;
                    tmp.push_back(num);
                    tmp.insert(tmp.end(), r.begin(), r.end());
                    res.push_back(tmp);
                }
            }
        }
        return res;
    }
}
```

<span id="二分查找"></span>
## [二分查找](#re_) [链接](https://www.acwing.com/blog/content/31/)
```cpp
// 方法1 [l, mid]和[mid + 1, r]
// 模板
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return l;
}
// 实例，升序，从左往右，第一个 >= NumberToFind的元素
int bsearch_1(int l, int r,int arr[],int NumberToFind){
    while (l < r){
        int mid = l + r >> 1;
        if (arr[mid] >= NumberToFind) r = mid;
        else l = mid + 1;
    }
    printf("%d",l);
    return l;
}

// 方法2 [l, mid - 1]和[mid, r]
// 模板
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
// 实例，升序，从右往左，第一个 <= NumberToFind的元素
int bsearch_1(int l, int r,int arr[],int NumberToFind){
    while (l < r){
        int mid = l + r + 1>> 1;
            if (arr[mid] <= NumberToFind) l = mid;
        else r = mid - 1;
    }
    printf("%d",l);
    return l;
}
```
